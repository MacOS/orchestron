import testing
import logging

import orchestron.ttx as ttx
#import orchestron.gdata as gdata
import yang.gdata as gdata


l1 = gdata.Container({
    "a": gdata.Leaf("int", 1),
    "l1": gdata.List(["name"], [
        gdata.ListElement(["k1"], {
            "n1": gdata.Leaf("int", 1),
            "n2": gdata.Leaf("int", 2)
        }),
        gdata.ListElement(["k4"], {
            "n4": gdata.Leaf("int", 4)
        })
    ])
})
tree1 = gdata.Container({
    'left': l1,
    'right': gdata.Container({
        "a": gdata.LeafList([1,2,3])
    })
})

l2 = gdata.Container({
    "b": gdata.Leaf("int", 2),
    "c": gdata.Leaf("int", 3),
    "l1": gdata.List(["name"], [
        gdata.ListElement(["k1"], {
            "n2": gdata.Leaf("int", 2)
        }),
        gdata.ListElement(["k2"], {
            "n1": gdata.Leaf("int", 1),
            "n3": gdata.Leaf("int", 3)
        })
    ]),
    "d": gdata.LeafList(["a", "b", "c"])
})
tree2 = gdata.Container({
    'left': l2,
    'right': gdata.Container({
        "b": gdata.Leaf("int", 1)
    })
})

merge_l1_l2 = gdata.Container({
    "a": gdata.Leaf("int", 1),
    "b": gdata.Leaf("int", 2),
    "c": gdata.Leaf("int", 3),
    "l1": gdata.List(["name"], [
        gdata.ListElement(["k1"], {
            "n1": gdata.Leaf("int", 1),
            "n2": gdata.Leaf("int", 2)
        }),
        gdata.ListElement(["k2"], {
            "n1": gdata.Leaf("int", 1),
            "n3": gdata.Leaf("int", 3)
        }),
        gdata.ListElement(["k4"], {
            "n4": gdata.Leaf("int", 4)
        })
    ]),
    "d": gdata.LeafList(["a", "b", "c"])
})
merge_tree = gdata.Container({
    'left': merge_l1_l2,
    'right': gdata.Container({
        "a": gdata.LeafList([1,2,3]),
        "b": gdata.Leaf("int", 1)
    })
})

########################

actor basic_commit_tester(done: action(?bool, ?Exception)->None):
    devices = ttx.Devices()
    out = devices.newsession()
    router_l = ttx.Transform(lambda cfg: cfg)()
    router_r = ttx.Transform(lambda cfg: cfg)()
    container = ttx.Container({
        'left': router_l,
        'right': router_r
    })
    t1 = container.newtrans()
    

    t1.configure("1", {'srcA': tree1}, out)

    def cont1(r1: value):
        t1.commit("1", True)
        r = t1.get()
        testing.assertEqual(r, tree1)
        done(True, None)

    t1.apply("1", out, cont1)

def _test_basic_commit(done, logger: logging.Handler):
    c = basic_commit_tester(done)

########################

actor overlapping_commit_tester(done: action(?bool, ?Exception)->None):
    devices = ttx.Devices()
    out = devices.newsession()
    router_l = ttx.Transform(lambda cfg: cfg)()
    router_r = ttx.Transform(lambda cfg: cfg)()
    container = ttx.Container({
        'left': router_l,
        'right': router_r
    })
    t1 = container.newtrans()
    t2 = container.newtrans()

    t1.configure("1", {'srcA': tree1}, out)
    t2.configure("2", {'srcB': tree2}, out)

    def cont1(_r: value):
        t1.commit("1", True)

    def cont2(_r: value):
        r1 = t1.get()
        testing.assertEqual(r1, tree1)
        t2.commit("2", True)
        r2 = t2.get()
        testing.assertEqual(r2, merge_tree)
        r1 = t1.get()
        testing.assertEqual(r1, r2)
        done(True, None)

    await async t1.apply("1", out, cont1)   # syncronous, so that t1 gets the lock first
    t2.apply("2", out, cont2)

def _test_overlapping_commit(done, logger: logging.Handler):
    c = overlapping_commit_tester(done)

########################

actor overlapping_commit_tester2(done: action(?bool, ?Exception)->None):
    devices = ttx.Devices()
    out = devices.newsession()
    router_l = ttx.Transform(lambda cfg: cfg)()
    router_r = ttx.Transform(lambda cfg: cfg)()
    container = ttx.Container({
        'left': router_l,
        'right': router_r
    })
    t1 = container.newtrans()
    t2 = container.newtrans()

    t1.configure("1", {'srcA': tree1}, out)
    t2.configure("2", {'srcB': tree2}, out)

    def cont2(_r: value):
        t2.commit("2", True)

    def cont1(_r: value):
        r2 = t2.get()
        testing.assertEqual(r2, tree2)
        t1.commit("1", True)
        r1 = t1.get()
        testing.assertEqual(r1, merge_tree)
        r2 = t2.get()
        testing.assertEqual(r1, r2)
        done(True, None)

    await async t2.apply("2", out, cont2)   # syncronous, so that t2 gets the lock first
    t1.apply("1", out, cont1)

def _test_overlapping_commit2(done, logger: logging.Handler):
    c = overlapping_commit_tester2(done)

########################


actor main(env):
    overlapping_commit_tester2(lambda s,e: env.exit(0))
