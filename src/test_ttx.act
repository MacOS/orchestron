import testing
import logging

import orchestron.ttx as ttx
#import orchestron.gdata as gdata
import yang.gdata as gdata


y1 = gdata.Container({
    "a": gdata.Leaf("int", 1),
    "l1": gdata.List(["name"], [
        gdata.ListElement(["k1"], {
            "n1": gdata.Leaf("int", 1),
            "n2": gdata.Leaf("int", 2)
        }),
        gdata.ListElement(["k4"], {
            "n4": gdata.Leaf("int", 4)
        })
    ])
})
y1_transp = {
    "a": {
        'src': gdata.Leaf("int", 1)
    },
    "l1": {
        'src': gdata.List(["name"], [
            gdata.ListElement(["k1"], {
                "n1": gdata.Leaf("int", 1),
                "n2": gdata.Leaf("int", 2)
            }),
            gdata.ListElement(["k4"], {
                "n4": gdata.Leaf("int", 4)
            })
        ])
    }
}
y1_transp_l1 = {
    "k1": {
        'src': gdata.ListElement(["k1"], {
            "n1": gdata.Leaf("int", 1),
            "n2": gdata.Leaf("int", 2)
        })
    },
    "k4": {
        'src': gdata.ListElement(["k4"], {
            "n4": gdata.Leaf("int", 4)
        })
    }
}
y1_transp_l1_k1 = {
    "n1": {
        'src': gdata.Leaf("int", 1)
    },
    "n2": {
        'src': gdata.Leaf("int", 2)
    }
}
y2 = gdata.Container({
    "b": gdata.Leaf("int", 2),
    "c": gdata.Leaf("int", 3),
    "l1": gdata.List(["name"], [
        gdata.ListElement(["k1"], {
            "n2": gdata.Leaf("int", 2)
        }),
        gdata.ListElement(["k2"], {
            "n1": gdata.Leaf("int", 1),
            "n3": gdata.Leaf("int", 3)
        })
    ]),
    "d": gdata.LeafList(["a", "b", "c"])
})
merge_y1_y2 = gdata.Container({
    "a": gdata.Leaf("int", 1),
    "b": gdata.Leaf("int", 2),
    "c": gdata.Leaf("int", 3),
    "l1": gdata.List(["name"], [
        gdata.ListElement(["k1"], {
            "n1": gdata.Leaf("int", 1),
            "n2": gdata.Leaf("int", 2)
        }),
        gdata.ListElement(["k2"], {
            "n1": gdata.Leaf("int", 1),
            "n3": gdata.Leaf("int", 3)
        }),
        gdata.ListElement(["k4"], {
            "n4": gdata.Leaf("int", 4)
        })
    ]),
    "d": gdata.LeafList(["a", "b", "c"])
})

########################

def _test_transpose():
    transp0 = ttx.transpose({'src': y1})
    testing.assertEqual(transp0, y1_transp)

    transp1 = ttx.transpose(transp0["l1"])
    testing.assertEqual(transp1, y1_transp_l1)

    transp2 = ttx.transpose(transp1["k1"])
    testing.assertEqual(transp2, y1_transp_l1_k1)

########################

def _test_multi_merge():
    mrg = gdata.merge(y1, y2)
    testing.assertEqual(mrg, merge_y1_y2)

    mrg1 = ttx.merge({'srcA': y1, 'srcB': y2})
    testing.assertEqual(mrg1, merge_y1_y2)

    mrg2: gdata.Node = ttx.merge({'srcB': y2})
    testing.assertEqual(mrg2, y2)

########################

def _test_diff_apply():
    fst = {
        'srcA': y1,
        'srcB': y2
    }
    snd = {
        'srcA': gdata.Container({
            'l1': gdata.Absent()
        }),
        'srcB': gdata.Container({
            "b": gdata.Leaf("int", 0),
            'l1': gdata.List(["name"], [
                gdata.AbsentListElement(["k2"])
            ]),
            'd': gdata.Absent()
        })
    }
    res = ttx.diff_apply(fst, snd)
    exp = {
        'srcA': gdata.Container({
            'a': gdata.Leaf("int", 1)
        }),
        'srcB': gdata.Container({
            "b": gdata.Leaf("int", 0),
            "c": gdata.Leaf("int", 3),
            "l1": gdata.List(["name"], [
                gdata.ListElement(["k1"], {
                    "n2": gdata.Leaf("int", 2)
                })
            ])
        })
    }
    testing.assertEqual(res, exp)

########################

actor basic_commit_tester(done: action(?bool, ?Exception)->None):
#    cfs = ttx.Container({
#        'netinfra':  ttx.Container({
#            'routers':       ttx.List(ttx.Transform(Router_cfs)),
#            'backbone-link': ttx.List(ttx.Transform(Backbone_cfs))
#        })
#    })
#    rfs = ttx.Container({
#        "rfs": ttx.List(lambda: ttx.Container({
#            "base-config": ttx.List(ttx.Transform(BaseConfig_rfs)),
#            "vrf": ttx.List(ttx.Transform(Vrf_rfs))
#        }))
#    })

    devices = ttx.Devices()
    out = devices.newsession()

#    stack = ttx.Layer(cfs, ttx.Layer(rfs, devices))

    router = ttx.Transform(lambda cfg: cfg)()
    trX = router.newtrans()
    # trX is reused several times below, knowing it's the constant
    # transaction actor of a Transform

    trX.configure("1", {'srcA': y1}, out)

    def cont1(r1: value):
        trX.commit("1", True)
        trX.configure("2", {'srcB': y2}, out)

        def cont2(r2: value):
            trX.commit("2", True)
            r = trX.get()
            trX.configure("3", {
                'srcA': gdata.Container({
                    'l1': gdata.Absent()
                }),
                'srcB': gdata.Container({
                    'b': gdata.Absent(),
                    'd': gdata.LeafList(['a','c'])
                })
            }, out)

            def cont3(r3: value):
                trX.commit("3", True)
                r = trX.get()
                expected = gdata.Container({
                    'a': gdata.Leaf("int", 1),
                    'c': gdata.Leaf("int", 3),
                    'l1': gdata.List(['name'], [
                        gdata.ListElement(['k1'], {
                            'n2': gdata.Leaf("int", 2)
                        }),
                        gdata.ListElement(['k2'], {
                            'n1': gdata.Leaf("int", 1),
                            'n3': gdata.Leaf("int", 3)
                        })
                    ]),
                    'd': gdata.LeafList(['a', 'c'])
                })
                testing.assertEqual(r, expected)
                done(True, None)

            trX.apply("3", out, cont3)

        trX.apply("2", out, cont2)

    trX.apply("1", out, cont1)

def _test_basic_commit(done, logger: logging.Handler):
    c = basic_commit_tester(done)

########################

actor overlapping_commit_tester(done: action(?bool, ?Exception)->None):
    devices = ttx.Devices()
    out = devices.newsession()
    router = ttx.Transform(lambda cfg: cfg)()
    trX = router.newtrans()
    # trX is reused several times below, knowing it's the constant
    # transaction actor of a Transform

    trX.configure("1", {'srcA': y1}, out)
    trX.configure("2", {'srcB': y2}, out)

    def cont1(r1: value):
        r = trX.get()
        testing.assertEqual(r, gdata.Absent())
        trX.commit("1", True)

    def cont2(r2: value):
        r = trX.get()
        testing.assertEqual(r, y1)
        trX.commit("2", True)
        r = trX.get()
        testing.assertEqual(r, merge_y1_y2)
        done(True, None)

    trX.apply("1", out, cont1)
    trX.apply("2", out, cont2)

def _test_overlapping_commit(done, logger: logging.Handler):
    c = overlapping_commit_tester(done)

########################

actor modified_commit_tester(done: action(?bool, ?Exception)->None):
    devices = ttx.Devices()
    out = devices.newsession()
    router = ttx.Transform(lambda cfg: cfg)()
    trX = router.newtrans()

    trX.configure("1", {'srcA': y1}, out)
    trX.configure("1", {'srcA': y2}, out)

    def cont1(r1: value):
        trX.commit("1", True)
        r = trX.get()
        testing.assertEqual(r, y2)
        done(True, None)

    trX.apply("1", out, cont1)

def _test_modified_commit(done, logger: logging.Handler):
    c = modified_commit_tester(done)

########################

actor modified_commit_tester2(done: action(?bool, ?Exception)->None):
    devices = ttx.Devices()
    out = devices.newsession()
    router = ttx.Transform(lambda cfg: cfg)()
    trX = router.newtrans()

    trX.configure("1", {'srcA': y1}, out)

    def cont1(r1: value):
        trX.configure("1", {'srcA': y2}, out)
        trX.commit("1", True)
        r = trX.get()
        testing.assertEqual(r, y2)
        done(True, None)

    trX.apply("1", out, cont1)

def _test_modified_commit2(done, logger: logging.Handler):
    c = modified_commit_tester2(done)

########################

y0 = gdata.Container({
    "a": gdata.Leaf("int", 0),
    "l1": gdata.List(["name"], [
        gdata.ListElement(["k4"], {
            "n4": gdata.Leaf("int", 0)
        })
    ]),
    "d": gdata.LeafList(["a", "b"])
})

actor modified_overlapping_commit_tester(done: action(?bool, ?Exception)->None):
    devices = ttx.Devices()
    out = devices.newsession()
    router = ttx.Transform(lambda cfg: cfg)()
    trX = router.newtrans()
    # trX is reused several times below, knowing it's the constant
    # transaction actor of a Transform

    trX.configure("1", {'srcA': y0}, out)
    trX.configure("2", {'srcB': y2}, out)

    def cont1(r1: value):
        trX.configure("1", {'srcA': y1}, out)
        trX.commit("1", True)

    def cont2(r2: value):
        trX.commit("2", True)
        r = trX.get()
        testing.assertEqual(r, merge_y1_y2)
        done(True, None)

    trX.apply("1", out, cont1)
    trX.apply("2", out, cont2)

def _test_modified_overlapping_commit(done, logger: logging.Handler):
    c = modified_overlapping_commit_tester(done)

########################

y3 = gdata.Container({
    "b": gdata.Leaf("int", 0),
    "c": gdata.Leaf("int", 0),
})

actor modified_overlapping_commit_tester2(done: action(?bool, ?Exception)->None):
    devices = ttx.Devices()
    out = devices.newsession()
    router = ttx.Transform(lambda cfg: cfg)()
    trX = router.newtrans()
    # trX is reused several times below, knowing it's the constant
    # transaction actor of a Transform

    trX.configure("1", {'srcA': y1}, out)
    trX.configure("2", {'srcB': y3}, out)

    def cont1(r1: value):
        trX.commit("1", True)

    def cont2(r2: value):
        trX.configure("2", {'srcB': y2}, out)
        trX.commit("2", True)
        r = trX.get()
        testing.assertEqual(r, merge_y1_y2)
        done(True, None)

    trX.apply("1", out, cont1)
    trX.apply("2", out, cont2)

def _test_modified_overlapping_commit2(done, logger: logging.Handler):
    c = modified_overlapping_commit_tester2(done)

########################

a0 = gdata.Container({
    'a': gdata.Leaf("int", 0)
})

a1 = gdata.Container({
    'a': gdata.Leaf("int", 1)
})

b1 = gdata.Container({
    'b': gdata.Leaf("int", 1)
})

a0b1 = gdata.Container({
    'a': gdata.Leaf("int", 0),
    'b': gdata.Leaf("int", 1)
})

actor config_failure_tester(done: action(?bool, ?Exception)->None):
    devices = ttx.Devices()
    out = devices.newsession()
    router = ttx.Transform(lambda cfg: cfg)()
    trX = router.newtrans()
    # trX is reused several times below, knowing it's the constant
    # transaction actor of a Transform

    trX.configure("1", {'srcA': a0}, out)
    trX.configure("2", {'srcB': a1}, out)

    def cont1(r1: value):
        trX.commit("1", True)

        def cont2(r2: value):
            if isinstance(r2, Exception):
                trX.configure("2", {'srcB': b1}, out)
            trX.commit("2", True)
            r = trX.get()
            testing.assertEqual(r, a0b1)
            done(True, None)

        trX.apply("2", out, cont2)

    trX.apply("1", out, cont1)

def _test_config_failure(done, logger: logging.Handler):
    c = config_failure_tester(done)

########################

actor config_abort_tester(done: action(?bool, ?Exception)->None):
    devices = ttx.Devices()
    out = devices.newsession()
    router = ttx.Transform(lambda cfg: cfg)()
    trX = router.newtrans()
    # trX is reused several times below, knowing it's the constant
    # transaction actor of a Transform

    trX.configure("1", {'srcA': a0}, out)
    trX.configure("2", {'srcB': a1}, out)

    def cont1(r1: value):
        trX.commit("1", False)

    def cont2(r2: value):
        trX.commit("2", True)
        r = trX.get()
        testing.assertEqual(r, a1)
        done(True, None)

    trX.apply("1", out, cont1)
    trX.apply("2", out, cont2)

def _test_config_abort(done, logger: logging.Handler):
    c = config_abort_tester(done)

########################

actor multi_apply_tester(done: action(?bool, ?Exception)->None):
    devices = ttx.Devices()
    out = devices.newsession()
    router = ttx.Transform(lambda cfg: cfg)()
    trX = router.newtrans()

    trX.configure("1", {'srcA': y1}, out)

    def cont1(r1: value):

        def cont2(r2: value):
            trX.configure("1", {'srcA': y2}, out)
            trX.commit("1", True)
            r = trX.get()
            testing.assertEqual(r, y2)
            done(True, None)

        trX.apply("1", out, cont2)

    trX.apply("1", out, cont1)

def _test_multi_apply(done, logger: logging.Handler):
    c = multi_apply_tester(done)

########################

actor empty_apply_tester(done: action(?bool, ?Exception)->None):
    devices = ttx.Devices()
    out = devices.newsession()
    router = ttx.Transform(lambda cfg: cfg)()
    trX = router.newtrans()
    # trX is reused several times below, knowing it's the constant
    # transaction actor of a Transform

    trX.configure("2", {'srcB': y3}, out)

    def cont1(r1: value):
        trX.commit("1", True)

    def cont2(r2: value):
        trX.configure("2", {'srcB': y2}, out)
        trX.commit("2", True)
        r = trX.get()
        testing.assertEqual(r, y2)
        done(True, None)

    trX.apply("1", out, cont1)
    trX.apply("2", out, cont2)

def _test_empty_apply(done, logger: logging.Handler):
    c = empty_apply_tester(done)

########################

actor empty_apply_tester2(done: action(?bool, ?Exception)->None):
    devices = ttx.Devices()
    out = devices.newsession()
    router = ttx.Transform(lambda cfg: cfg)()
    trX = router.newtrans()
    # trX is reused several times below, knowing it's the constant
    # transaction actor of a Transform

    trX.configure("2", {'srcB': y3}, out)

    def cont1(r1: value):
        trX.commit("1", True)

    def cont2(r2: value):
        trX.configure("2", {'srcB': y2}, out)
        trX.commit("2", True)
        r = trX.get()
        testing.assertEqual(r, y2)
        done(True, None)

    trX.apply("2", out, cont2)
    trX.apply("1", out, cont1)

def _test_empty_apply2(done, logger: logging.Handler):
    c = empty_apply_tester2(done)

########################

actor spurious_commit_tester(done: action(?bool, ?Exception)->None):
    devices = ttx.Devices()
    out = devices.newsession()
    router = ttx.Transform(lambda cfg: cfg)()
    trX = router.newtrans()
    # trX is reused several times below, knowing it's the constant
    # transaction actor of a Transform

    trX.configure("1", {'srcA': y1}, out)

    def cont1(r1: value):
        trX.commit("2", True)

        trX.commit("1", True)
        r = trX.get()
        testing.assertEqual(r, y1)
        done(True, None)

    trX.apply("1", out, cont1)

def _test_spurious_commit(done, logger: logging.Handler):
    c = spurious_commit_tester(done)

########################

actor spurious_config_tester(done: action(?bool, ?Exception)->None):
    devices = ttx.Devices()
    out = devices.newsession()
    router = ttx.Transform(lambda cfg: cfg)()
    trX = router.newtrans()
    # trX is reused several times below, knowing it's the constant
    # transaction actor of a Transform

    trX.configure("1", {'srcA': y1}, out)
    trX.configure("2", {'srcB': y2}, out)

    def cont1(r1: value):
        trX.configure("2", {'srcB': y3}, out)
        trX.commit("2", True)

        trX.commit("1", True)
        r = trX.get()
        testing.assertEqual(r, y1)
        done(True, None)

    trX.apply("1", out, cont1)

def _test_spurious_config(done, logger: logging.Handler):
    c = spurious_config_tester(done)

########################


actor main(env):
    empty_apply_tester2(lambda s,e: env.exit(0))
