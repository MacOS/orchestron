import yang.adata
#import orchestron.gdata as gdata
import yang.gdata as gdata
import orchestron.device as odev
from orchestron.device_meta_config import orchestron_rfs__device_entry as DeviceMetaConfig
import xml, logging

def transpose(cfg_per_src: dict[str, gdata.Node]) -> dict[str, dict[str, gdata.Node]]:
    cfg_per_key = {}
    for src, conf in cfg_per_src.items():
        if isinstance(conf, gdata.List):
            for le in conf.elements:
                key = le.key_str()
                if key in cfg_per_key:
                    cfg_per_key[key][src] = le
                else:
                    cfg_per_key[key] = {src: le}
        elif isinstance(conf, gdata.Inner):
            for key, subconf in conf.children.items():
                if key in cfg_per_key:
                    cfg_per_key[key][src] = subconf
                else:
                    cfg_per_key[key] = {src: subconf}
        else:
            raise NotImplementedError("Cannot transpose configuration type" + str(type(conf)))

    return cfg_per_key

def difference(a: ?gdata.Node, b: gdata.Node) -> gdata.Node:
    if a is not None:
        d = gdata.diff(a, b)
        return d if d is not None else gdata.Absent()
    else:
        return b

def patch(conf: dict[str,gdata.Node], diff: dict[str,gdata.Node]) -> dict[str,gdata.Node]:
    res = {}
    for s,d in diff.items():
        if s in conf:
            p = gdata.patch(conf[s], d)
            if p is not None:
                res[s] = p
        else:
            res[s] = d
    for s,c in conf.items():
        if s not in diff:
            res[s] = c
    return res

def assert_complete(conf: gdata.Node):
    return conf

def merge(cfg_per_src: dict[str,gdata.Node]):
    acc = None
    for conf in cfg_per_src.values():
        if acc is not None:
            acc = gdata.merge(acc, conf)
        else:
            acc = conf
    if acc is not None:
        return acc
    else:
        raise ValueError("Nothing to merge")


##################### Node & Transactions #####################

class YieldState(object):
    it: Iterator[str]
    key: str
    tid: str
    out: Session
    results: dict[str,value]
    @property
    done: action(value) -> None

    def __init__(self, it, key, tid, out, done):
        self.it = it
        self.key = key
        self.tid = tid
        self.out = out
        self.results = {}
        self.done = done


actor Node(impl: _Node):
    def newtrans():
        return impl.newtrans()

    def get():
        return impl.get()

class _Node(object):
    path: list[str]
    newtrans: proc() -> Transaction
    get: proc() -> gdata.Node


actor Transaction(impl: _Transaction):
    def configure(tid, diff, out, force=False):
        return impl.configure(tid, diff, out, force)

    # yield action
    def lock(tid, out, done):
        impl.lock(self, tid, out, done)

    def lock_cont(res):
        impl.lock_cont(self, res)

    def commit(tid, ok):
        impl.commit(tid, ok)

    def on_completion(tid, out, done):
        impl.on_completion(self, tid, out, done)

    def on_completion_cont(res):
        impl.on_completion_cont(self, res)

    def get():
        return impl.get()

class _Transaction(object):
    path: list[str]
    configure:  proc(tid: str, diff: dict[str,gdata.Node], out: Session, force: ?bool) -> value
    # yield action
    lock : proc(actself: Transaction, tid: str, out: Session, done: action(value) -> None) -> None
    lock_cont : proc(actself: Transaction, res: value) -> None
    commit: proc(tid: str, ok: bool) -> None
    on_completion: proc(actself: Transaction, tid: str, out: Session, done: action(value) -> None) -> None
    on_completion_cont : proc(actself: Transaction, res: value) -> None
    get: proc() -> gdata.Node


####################### Layer ########################

actor GenLayer(impl: _GenLayer):

    def newsession():
        return impl.newsession()

    def below():
        return impl.below()

    def edit_config(diff, done=None, force=False):
        newsession().edit_config(diff, done, force)

    def get():
        return impl.get()

class _GenLayer(object):
    newsession: proc() -> Session
    below: proc() -> GenLayer
    get: proc() -> gdata.Node


actor Session(impl: _Session):
    # yield action
    def edit_config(diff, done=None, force=False):
        impl.edit_config(self, diff, done, force)

    def edit_config_cont(res):
        impl.edit_config_cont(res)

    def configure(tid, diff_per_source):
        impl.configure(tid, diff_per_source)

    def apply(tid, force=False):
        return impl.apply(tid, force)

    def lock(tid, done):
        impl.lock(self, tid, done)

    def lock_cont1(res):
        impl.lock_cont1(self, res)

    def lock_cont2(res):
        impl.lock_cont2(res)

    def commit(tid, ok):
        impl.commit(tid, ok)

    def on_completion(done):
        impl.on_completion(done)

    def get():
        return impl.get()

    def below():
        return impl.below(self)

class _Session(object):
    edit_config:        proc(actself: Session, diff: gdata.Node, done: ?action(value)->None, force: ?bool) -> None
    edit_config_cont:   proc(res: value) -> None
    configure:          proc(tid: str, diff_per_source: dict[str,gdata.Node]) -> None
    apply:              proc(tid: str, force: ?bool) -> value
    lock:               proc(actself: Session, tid: str, done: action(value)->None) -> None
    lock_cont1:         proc(actself: Session, res: value) -> None
    lock_cont2:         proc(res: value) -> None
    commit:             proc(tid: str, ok: bool) -> None
    on_completion:      proc(done: action(value)->None) -> None
    get:                proc() -> gdata.Node
    below:              proc(actself: Session) -> Session


def Layer(name: str, root: proc(list[str])->Node, lower: GenLayer):
    return GenLayer(_Layer(name, root, lower))

class _Layer(_GenLayer):
    name: str
    root: Node
    lower: GenLayer

    def __init__(self, name, root: proc(list[str])->Node, lower: GenLayer):
        self.name = name
        self.root = root(["("+name+")"])
        self.lower = lower

    def newsession(self):
        return LayerSession(self.name, self.root, self.lower)

    def below(self):
        return self.lower

    def get(self):
        return self.root.get()


def Sink():
    return GenLayer(_Sink(SinkSession()))

class _Sink(_GenLayer):
    session: Session

    def __init__(self, session):
        self.session = session

    def newsession(self):
        return self.session

    def below(self):
        return GenLayer(self)

    def get(self):
        return gdata.Container()


def LayerSession(name: str, rootnode: Node, lowerlayer: GenLayer):
    return Session(_LayerSession(name, rootnode.newtrans(), lowerlayer.newsession()))

class _LayerSession(_Session):
    root: Transaction
    lower: Session
    buf: dict[str, dict[str,gdata.Node]]
    lock_cont: ?action(value)->None
    done_cont: ?action(value)->None
    tid: ?str

    def __init__(self, name: str, root: Transaction, lower: Session):
        self.name = name
        self.root = root
        self.lower = lower
        self.buf = {}
        self.lock_cont = None
        self.done_cont = None
        self.tid = None

    # yield action
    def edit_config(self, actself, diff: gdata.Node, done, force=False):
        tid = 'tr_' + str(self)[-10:-1]
        #print('#### (Layer)', self.name, 'edit_config', tid)
        self.done_cont = done
        self.configure(tid, {'_': diff})
        res = self.apply(tid, force)
        #print('   # (Layer)', self.name, 'EXECUTE', tid, 'PREP RESULT', res)
        if isinstance(res, str) and res == 'Ok':
            self.lock(actself, tid, actself.edit_config_cont)       # yield await

    def edit_config_cont(self, res: value):
        done_cont = self.done_cont
        tid = self.tid
        #print('#### (Layer)', self.name, 'edit_config_cont', tid)
        if tid is not None:
            self.commit(tid, isinstance(res, str) and res == 'Ok')
            if done_cont is not None:
                #print('   # (Layer)', self.name, 'EXECUTE', tid, 'DONE', res)
                done_cont(res)
        self.done_cont = None
        self.tid = None

    def configure(self, tid: str, diff_per_source: dict[str,gdata.Node]):
        if tid not in self.buf:
            self.buf[tid] = {}
        self.buf[tid].update(diff_per_source.items())

    def apply(self, tid, force=False):
        #print('#### (Layer)', self.name, 'apply', tid)
        buf = self.buf.get_def(tid, {})
        #for src,tree in buf.items():
        #    print('   # (Layer)', self.name, 'APPLY', src, ':', tree.prsrc())
        res = self.root.configure(tid, buf, self.lower, force)
        self.buf.pop(tid)
        if not isinstance(res, Exception):
            res = self.lower.apply(tid)
        rr = 'Ok' if isinstance(res, str) and res == 'Empty' else res
        #print('   # (Layer)', self.name, 'APPLY', tid, 'RESULT', rr)
        return rr

    # yield action
    def lock(self, actself, tid: str, done: action(value) -> None):
        #print('#### (Layer)', self.name, 'lock', tid)
        self.tid = tid
        self.lock_cont = done
        self.root.lock(tid, self.lower, actself.lock_cont1)     # yield await

    def lock_cont1(self, actself, res: value):
        tid = self.tid
        #print('#### (Layer)', self.name, 'lock_cont1', tid)
        if tid is not None:
            if not isinstance(res, Exception):
                #print('   # (Layer)', self.name, 'FINALIZE LOWER', tid)
                self.lower.lock(tid, actself.lock_cont2)        # yield await

    def lock_cont2(self, res: value):
        #print('#### (Layer)', self.name, 'lock_cont2')
        lock_cont = self.lock_cont
        if lock_cont is not None:
            self.lock_cont = None
            rr = 'Ok' if isinstance(res, str) and res == 'Empty' else res
            #print('   # (Layer)', self.name, 'FINALIZE RESULT', rr)
            lock_cont(rr)

    def commit(self, tid, ok):
        #print('#### (Layer)', self.name, 'commit', tid, ok)
        self.root.commit(tid, ok)
        self.lower.commit(tid, ok)

    def on_completion(self, done):
        #print('#### (Layer)', self.name, 'on_completion', self.tid)
        tid = self.tid
        if tid is not None:
            self.root.on_completion(tid, self.lower, done)

    def get(self):
        return self.root.get()

    def below(self, actself):
        return self.lower


def SinkSession():
    return Session(_SinkSession())

class _SinkSession(_Session):
    buf: dict[str, dict[str,gdata.Node]]
    cfg: dict[str,gdata.Node]

    def __init__(self):
        self.buf = {}
        self.cfg = {}

    # yield action
    def edit_config(self, actself, diff: gdata.Node, done, force=False):
        if done is not None:
            done('Ok')      # For now...

    def edit_config_cont(self, res: value):
        pass

    def configure(self, tid: str, diff_per_source: dict[str,gdata.Node]):
        #print('#### (Sink) configure', tid, 'sources', list(diff_per_source.keys()))
        if tid not in self.buf:
            self.buf[tid] = {}
        self.buf[tid].update(diff_per_source.items())

    def apply(self, tid, force=False):
        #print('#### (Sink) apply', tid)
        if tid in self.buf:
            self.cfg = patch(self.cfg, self.buf[tid])
            del self.buf[tid]
        return 'Ok'

    # yield action
    def lock(self, actself, tid: str, done: action(value) -> None):
        done('Ok')      # For now...

    def lock_cont1(self, actself, res: value):
        pass

    def lock_cont2(self, res: value):
        pass

    def commit(self, tid, ok):
        #print('#### (Sink) commit', tid, ok)
        pass

    def on_completion(self, done):
        done('Ok')

    def get(self):
        merged = merge(self.cfg)
        return merged

    def below(self, actself):
        return actself


############## Containers ##################

def Container(template={}):
    return lambda path: Node(_Container(path, template))

class _Container(_Node):
    elems: dict[str, Node]

    def __init__(self, path, template: dict[str, proc(list[str])->Node]):
        self.path = path
        self.elems = {}
        for key,templ in template.items():
            self.elems[key] = templ(path+[key])

    def newtrans(self):
        return ContainerTransaction(self.path, self.elems)

    def get(self):
        res = {}
        for tag,node in self.elems.items():
            res[tag] = node.get()
        return gdata.Container(res)


def ContainerTransaction(path, contents):
    return Transaction(_ContainerTransaction(path, contents))

class _ContainerTransaction(_Transaction):
    elems : dict[str, Transaction]
    accum : dict[str, value]
    state : ?YieldState

    def __init__(self, path, contents):
        self.path = path
        self.elems = {}
        self.accum = {}
        self.state = None
        for key,node in contents.items():
            self.elems[key] = node.newtrans()

    def configure(self, tid, diff, out, force=False):
        #print('#### (Container)', self.path, 'configure', tid, force)
        diff_by_child = transpose(diff)
        if len(diff_by_child) == 0 and force:
            for k in self.elems.keys():
                diff_by_child[k] = {}
        msgs = {}
        for child,subdiff in diff_by_child.items():
            if child in self.elems:
                #print('   # (Container)', self.path, 'CONFIGURE CHILD', child)
                msgs[child] = async self.elems[child].configure(tid, subdiff, out, force)
        results = {}
        for child,msg in msgs.items():
            results[child] = await msg
            #print('   # (Container), self.path, 'RESULT CHILD', child, ':', results[child])
        return self._analyze(results)

    def _analyze(self, results):
        self.accum.update(results.items())
        for r in results.values():
            if isinstance(r, Exception):
                #print('   # (Container)', self.path, 'RESULT:', r)
                return r
        #print('   # (Container)', self.path, 'RESULT:', 'Ok')
        return 'Ok'

    # yield action
    def lock(self, actself, tid, out, done):
        #print('#### (Container)', self.path, 'lock', tid)
        it = iter(sorted(self.accum.keys()))
        try:
            key = next(it)
            self.state = YieldState(it, key, tid, out, done)
            tr = self.elems[key]
            #print('   # (Container)', self.path, 'LOCK CHILD', key)
            tr.lock(tid, out, actself.lock_cont)                    # yield await
        except StopIteration:
            #print('   # (Container)', self.path, 'LOCK IMMEDIATELY DONE')
            done('Ok')

    proc def lock_cont (self, actself, res):
        state = self.state
        if state is not None:
            #print('   # (Container)', self.path, 'LOCK', state.tid, 'CHILD', state.key, 'RESULT:', res)
            state.results[state.key] = res
            try:
                key = next(state.it)
                state.key = key
                tr = self.elems[key]
                #print('   # (Container)', self.path, 'LOCK CHILD', key)
                tr.lock(state.tid, state.out, actself.lock_cont)
            except StopIteration:
                self.state = None
                #print('   # (Container)', self.path, 'LOCK DONE')
                state.done(self._analyze(state.results))
        else:
            #print('#### (Container)', self.path, 'lock_cont empty state!!!')
            pass

    proc def commit(self, tid, ok):
        #print('#### (Container)', self.path, 'commit', tid, ok)
        for child in self.accum.keys():
            #print('   # (Container)', self.path, 'COMMIT CHILD', child)
            self.elems[child].commit(tid, ok)
        #print('   # (Container)', self.path, 'COMMIT DONE')
        self.accum = {}

    # yield action
    def on_completion(self, actself, tid, out, done):
        #print('#### (Container)', self.path, 'on_completion', tid, list(self.accum.keys()))
        it = iter(sorted(self.elems.keys()))
        try:
            key = next(it)
            self.state = YieldState(it, key, tid, out, done)
            tr = self.elems[key]
            #print('   # (Container)', self.path, 'COMPLETE CHILD', key)
            tr.on_completion(tid, out, actself.on_completion_cont)             # yield await
        except StopIteration:
            #print('   # (Container)', self.path, 'COMPLETION IMMEDIATELY DONE')
            done('Ok')

    proc def on_completion_cont (self, actself, res):
        state = self.state
        if state is not None:
            #print('   # (Container)', self.path, 'COMPLETE', state.tid, 'CHILD', state.key, 'RESULT:', res)
            state.results[state.key] = res
            try:
                key = next(state.it)
                state.key = key
                tr = self.elems[key]
                #print('   # (Container)', self.path, 'COMPLETE CHILD', key)
                tr.on_completion(state.tid, state.out, actself.on_completion_cont)
            except StopIteration:
                self.state = None
                #print('   # (Container)', self.path, 'COMPLETION DONE')
                state.done(self._analyze(state.results))
        else:
            #print('#### (Container)', self.path, 'on_completion_cont empty state!!!')
            pass

    def get(self):
        res = {}
        for tag,node in self.elems.items():
            res[tag] = node.get()
        return gdata.Container(res)


################# Lists ####################

def List(template):
    return lambda path: Node(_List(path, template))

class _List(_Node):
    liststate: ListState

    def __init__(self, path, template):
        self.path = path
        self.liststate = ListState(path, template)

    def newtrans(self):
        return ListTransaction(self.path, self.liststate)

    def get(self):
        res = []
        for key,node in self.liststate.all().items():
            r = node.get()
            if isinstance(r, gdata.ListElement):
                res.append(r)
        return gdata.List(["name"], res)


actor ListState(path, template: proc(list[str]) -> Node):
    var elems = {}
    var active = {}
    var provisional = set()

    def acquire(tid: str, keys: ?set[str]):
        #print("==== acquire", path, tid, "keys:", keys, "new:", new, "provisional:", provisional)
        result = {}
        if keys is not None:
            keys1 = keys
            new = keys - set(elems.keys())
            for k in new:
                elems[k] = template(path+[k])
            provisional |= new
        else:
            keys1 = set(elems.keys())
        active[tid] = keys1
        for k in keys1:
            result[k] = elems[k]
        return result

    def release(tid: str, ok: bool, deletes: set[str]):
        #print("==== release", path, tid, ok, "deletes:", deletes, "provisional:", provisional)
        if ok:
            provisional -= active[tid]
            provisional |= deletes
        del active[tid]
        if not active:
            #print("==== delete", path, tid, provisional)
            for k in provisional:
                del elems[k]
            provisional = set()

    def all():
        return dict(elems.items())


class _ListTransaction(_Transaction):
    liststate : ListState
    elems : dict[str, Transaction]
    accum : dict[str, value]
    state : ?YieldState
    reset: bool

    def __init__(self, path, liststate):
        self.path = path
        self.liststate = liststate
        self.elems = {}
        self.accum = {}
        self.state = None
        self.reset = False

    def configure(self, tid, diff, out, force=False):
        #print('#### (List)', self.path, 'configure', tid)
        if self.reset:
            self.elems = {}
            self.accum = {}
            self.reset = False
        diff_by_key = transpose(diff)
        if len(diff_by_key) == 0 and force:
            for k in self.liststate.acquire(tid, None).keys():
                diff_by_key[k] = {}
        keys = set(diff_by_key.keys())
        for key,node in self.liststate.acquire(tid, keys).items():
            self.elems[key] = node.newtrans()
        msgs = {}
        for key,subdiff in diff_by_key.items():
            #print('   # (List)', self.path, 'CONFIGURE ELEMENT', key)
            msgs[key] = async self.elems[key].configure(tid, subdiff, out, force)
        results = {}
        for key,msg in msgs.items():
            results[key] = await msg
            v = results[key]
            #print('   # (List)', self.path, 'RESULT ELEMENT', key, ':', v)
        return self._analyze(results)

    def _analyze(self, results: dict[str,value]):
        self.accum.update(results.items())
        res = 'Empty'
        for key,r in results.items():
            if isinstance(r, Exception):
                #print('   # (List)', self.path, 'RESULT:', r)
                return r
            if isinstance(r, str) and r == 'Ok':
                res = r
        #print('   # (List)', self.path, 'RESULT:', res)
        return res

    # yield action
    def lock(self, actself, tid, out, done):
        #print('#### (List)', self.path, 'lock', tid)
        it = iter(sorted(self.accum.keys()))
        try:
            key = next(it)
            self.state = YieldState(it, key, tid, out, done)
            tr = self.elems[key]
            #print('   # (List)', self.path, 'LOCK ELEMENT', key)
            tr.lock(tid, out, actself.lock_cont)                        # yield await
        except StopIteration:
            #print('   # (List)', self.path, 'LOCK IMMEDIATELY DONE')
            done('Ok')

    def lock_cont (self, actself, res):
        state = self.state
        if state is not None:
            #print('   # (List)', self.path, 'LOCK', state.tid, 'ELEMENT', state.key, 'RESULT:', res)
            state.results[state.key] = res
            try:
                key = next(state.it)
                state.key = key
                tr = self.elems[key]
                #print('   # (List)', self.path, 'LOCK ELEMENT', key)
                tr.lock(state.tid, state.out, actself.lock_cont)
            except StopIteration:
                self.state = None
                #print('   # (List)', self.path, 'LOCK DONE')
                state.done(self._analyze(state.results))
        else:
            pass
            #print('#### (List)', self.path, 'lock_cont empty state!!!')

    def commit(self, tid, ok):
        #print('#### (List)', self.path, 'commit', tid, ok)
        for key,tr in self.elems.items():
            #print('   # (List)', self.path, 'COMMIT ELEMENT', key)
            tr.commit(tid, ok)
        deletes = set()
        for key,res in self.accum.items():
            if isinstance(res, str) and res == 'Empty':
                #print('   # (List)', self.path, 'DELETE ELEMENT', key)
                deletes.add(key)
        self.liststate.release(tid, ok, deletes)
        self.reset = True       # Defer resetting accum, for the benefit of 'on_completion'

    # yield action
    def on_completion(self, actself, tid, out, done):
        #print('#### (List)', self.path, 'on_completion', tid, list(self.accum.keys()))
        it = iter(sorted(self.accum.keys()))
        try:
            key = next(it)
            self.state = YieldState(it, key, tid, out, done)
            tr = self.elems[key]
            #print('   # (List)', self.path, 'COMPLETE ELEMENT', key)
            tr.on_completion(tid, out, actself.on_completion_cont)               # yield await
        except StopIteration:
            #print('   # (List)', self.path, 'COMPLETION IMMEDIATELY DONE')
            done('Ok')

    def on_completion_cont (self, actself, res):
        state = self.state
        if state is not None:
            #print('   # (List)', self.path, 'COMPLETE', state.tid, 'ELEMENT', state.key, 'RESULT:', res)
            state.results[state.key] = res
            try:
                key = next(state.it)
                state.key = key
                tr = self.elems[key]
                #print('   # (List)', self.path, 'COMPLETE ELEMENT', key)
                tr.on_completion(state.tid, state.out, actself.on_completion_cont)
            except StopIteration:
                self.state = None
                #print('   # (List)', self.path, 'COMPLETION DONE')
                state.done(self._analyze(state.results))
        else:
            pass
            #print('#### (List)', self.path, 'on_completion_cont empty state!!!')

    def get(self):
        res = []
        for key,node in self.liststate.all().items():
            r = node.get()
            if isinstance(r, gdata.ListElement):
                res.append(r)
        return gdata.List(["name"], res)

def ListTransaction(path, liststate:ListState):
    return Transaction(_ListTransaction(path, liststate))


################# Transform #####################

class _TransformBase(_Node):
    transaction: Transaction

    def newtrans(self):
        return self.transaction

    def get(self):
        return self.transaction.get()


class _TransformTransactionBase(_Transaction):
    inputs: dict[str, dict[str, gdata.Node]]
    config: dict[str, gdata.Node]
    candidates: dict[str, (dict[str,gdata.Node], ?gdata.Node)]
    output: ?gdata.Node
    locker: ?str
    pending: list[(Transaction, str, Session, action(value)->None)]
    me: str

    compute : proc(tid: str, merged: gdata.Node, out: Session) -> gdata.Node
    finalize : proc(tid: str) -> None

    def __init__(self, path):
        self.path = path
        self.inputs = {}
        self.config = {}
        self.candidates = {}
        self.output = None
        self.locker = None
        self.pending = []
        self.me = '(src_' + str(self)[-10:-1] + ')'

    def configure(self, tid, diff, out, force=False):
        #print('#### (Transform)', self.path, 'configure', tid, "src:", self.me)
        if tid in self.inputs:
            self.inputs[tid].update(diff.items())
        else:
            self.inputs[tid] = diff
        inp = self.inputs[tid]
        newconf = patch(self.config, inp)
        #for s,c in inp.items():
        #    print("# INPUT", self.path, tid, s, ":", c.prsrc())
        #for s,c in self.config.items():
        #    print("   # CURRENT", self.path, tid, s, ":", c.prsrc())
        #for s,c in newconf.items():
        #    print("   # NEWCONF", self.path, tid, s, ":", c.prsrc())
        if newconf == self.config and not force:
            self.candidates[tid] = (self.config, self.output)
            #print('   # (Transform) NO CHANGE', self.path, tid)
            return 'Ok'
        elif newconf == {}:
            self.candidates[tid] = ({}, None)
            #print('   # (Transform) EMPTY RESULT', self.path, tid)
            return 'Empty'
        else:
            try:
                merged = assert_complete(merge(newconf))
                #print('   # (Transform)', self.path, tid, 'MERGED', merged.prsrc())
#                assert self.validate(merged)
            except Exception as e:
                #print('   # (Transform) FAILURE', self.path, tid, e)
                return e
            else:
                newout = self.compute(tid, merged, out)
                self.candidates[tid] = (newconf, newout)
                #print('   # (Transform)', self.path, tid, 'OUTPUT', newout.prsrc())
                return 'Ok'
        return 'Ok'

    # yield action
    def lock(self, actself, tid, out, done):                            # yield await
        #print('#### (Transform)', self.path, 'lock', tid)
        locker = self.locker
        if locker is not None:
            if locker == tid:
                #print('   # (Transform)', self.path, 'REDUNDANT LOCK', tid)
                done('Ok')
            else:
                #print('   # (Transform)', self.path, 'SUSPENDING', tid)
                self.pending.append((actself, tid, out, done))          # suspend
            return
        self.locker = tid
        if tid not in self.candidates:
            inp = self.inputs.get_def(tid, {})
            #print('   # (Transform)', self.path, 'RE-CONFIGURING', tid)
            res = self.configure(tid, inp, out)
            done(res)
        else:
            #print('   # (Transform)', self.path, 'LOCKING', tid)
            done('Ok' if self.candidates[tid].0 else 'Empty')

    def lock_cont (self, actself, res):
        pass

    def commit(self, tid, ok):
        #print('#### (Transform)', self.path, 'commit', tid, ok)
        self.inputs.pop(tid)
        if tid == self.locker:
            if ok and tid in self.candidates:
                config, output = self.candidates[tid]
                self.config = config
                self.output = output
                self.candidates = {}
                #print('   # (Transform)', self.path, 'COMMITTING', tid)
                self.finalize(tid)
            else:
                #print('   # (Transform)', self.path, 'ABORTING', tid)
                self.candidates.pop(tid)
            self.locker = None
            if self.pending:
                (actself, tid2, out, done) = self.pending.pop(0)
                #print("   # (Transform)', self.path, 'RESUMING", tid2)
                self.lock(actself, tid2, out, done)                     # resume
        else:
            #print('   # (Transform)', self.path, 'IGNORING', tid)
            self.candidates.pop(tid)

    def finalize(self, tid):
        pass

    def on_completion(self, actself, tid, out, done):                            # (yield await)
        #print('#### (Transform)', self.path, 'on_completion', tid)
        done('Ok')

    def on_completion_cont (self, actself, res):
        pass

    def get(self):
        if self.config:
            return merge(self.config)
        else:
            return gdata.Absent()


def Transform(function, log_handler: ?logging.Handler=None):
    return lambda path: Node(_Transform(path, function, log_handler))

class _Transform(_TransformBase):
    def __init__(self, path, function, log_handler):
        self.path = path
        self.transaction = TransformTransaction(path, function, log_handler)


def TransformTransaction(path, function, log_handler):
    return Transaction(_TransformTransaction(path, function, log_handler))

class _TransformTransaction(_TransformTransactionBase):
    function: TransformFunction

    def __init__(self, path, function: proc(?logging.Handler) -> TransformFunction, log_handler):
        _TransformTransactionBase.__init__(self, path)
        self.function = function(log_handler)

    def compute(self, tid, merged, out):
        newout = self.function.transform_wrapper(merged)
        res = difference(self.output, newout)
        out.configure(tid, {self.me: res})
        return newout

class TransformFunction(object):
    transform_wrapper: mut(gdata.Node) -> gdata.Node
    transform_xml: mut(xml.Node) -> gdata.Node
    logger: logging.Logger

    def __init__(self, log_handler: ?logging.Handler=None):
        self.logger = logging.Logger(log_handler)

    def transform_wrapper(self, cfg):
        return gdata.Absent()

    def transform_xml(self, cfg):
        return gdata.Absent()


################# RFSTransform ###################

def RFSTransform(function, dev_mgr: odev.DeviceManager, log_handler: ?logging.Handler=None):
    return lambda path: Node(_RFSTransform(path, function, dev_mgr, log_handler))

class _RFSTransform(_TransformBase):
    def __init__(self, path, function, dev_mgr, log_handler):
        self.path = path
        self.transaction = RFSTransaction(path, function, dev_mgr, log_handler)

def RFSTransaction(path, function, dev_mgr, log_handler):
    return Transaction(_RFSTransaction(path, function, dev_mgr, log_handler))

class _RFSTransaction(_TransformTransactionBase):
    function: RFSFunction
    devname: str
    dev: odev.Device

    def __init__(self, path, function: proc(?logging.Handler) -> RFSFunction, dev_mgr: odev.DeviceManager, log_handler):
        _TransformTransactionBase.__init__(self, path)
        self.function = function(log_handler)
        if len(path) < 3:
            raise ValueError("RFSTransform " + str(path) + ": path length < 3")
        self.devname = path[-3]
        self.dev = dev_mgr.get(self.devname)

    def compute(self, tid, merged, out):
        #print('#### (RFSTransform)', self.path, 'compute', tid)
        modcap = self.dev.get_modules()
        if len(modcap) > 0:
            newout = self.function.transform_wrapper(merged, DeviceInfo(self.devname, modcap))
        else:
            #print("No device capabilities, skipping RFS transform for", devname)
            newout = gdata.Root({})
        res = difference(self.output, newout)

        if isinstance(res, gdata.Inner):
            embedded_res = gdata.Module({
                "devices": gdata.Container({
                    "device": gdata.List(["name"], [
                        gdata.ListElement([self.devname], {
                            "name": gdata.Leaf("str", self.devname),
                            "config": gdata.Container(res.children)
                        })
                    ])
                })
            }, ns="http://orchestron.org/yang/orchestron-device.yang")
            out.configure(tid, {self.me: embedded_res})

        return newout


class DeviceInfo(object):
    name: str
    modules: dict[str, odev.ModCap]

    def __init__(self, name: str, modules: dict[str, odev.ModCap] = {}):
        self.name = name
        self.modules = modules

class RFSFunction(object):
    transform_wrapper: mut(gdata.Node, DeviceInfo) -> gdata.Node
    transform_xml: mut(xml.Node, DeviceInfo) -> gdata.Node
    logger: logging.Logger

    def __init__(self, log_handler: ?logging.Handler=None):
        self.logger = logging.Logger(log_handler)

    def transform_wrapper(self, cfg, di):
        return gdata.Absent()

    def transform_xml(self, cfg, di):
        return gdata.Absent()


################# Device #####################

def Device(dev_mgr: odev.DeviceManager, log_handler: ?logging.Handler=None):
    return lambda path: Node(_Device(path, dev_mgr, log_handler))

class _Device(_TransformBase):
    def __init__(self, path, dev_mgr, log_handler):
        self.path = path
        self.transaction = DeviceTransaction(path, dev_mgr, log_handler)

def DeviceTransaction(path, dev_mgr, log_handler):
    return Transaction(_DeviceTransaction(path, dev_mgr, log_handler))

class _DeviceTransaction(_TransformTransactionBase):
    dev: odev.Device
    logger: logging.Logger

    def __init__(self, path, dev_mgr: odev.DeviceManager, log_handler):
        _TransformTransactionBase.__init__(self, path)
        self.dev = dev_mgr.get(path[-1])
        self.logger = logging.Logger(log_handler)

    def compute(self, tid, merged, out):
        return merged

    def finalize(self, tid):
        #print('#### (Device)', self.path, 'finalize', tid)
        config = self.output
        if config is not None:
            meta_config = DeviceMetaConfig.from_gdata(config)
            self.dev.set_meta_config(meta_config)


################# DeviceConfig #####################

def DeviceConfig(dev_mgr: odev.DeviceManager, log_handler: ?logging.Handler=None):
    return lambda path: Node(_DeviceConfig(path, dev_mgr, log_handler))

class _DeviceConfig(_TransformBase):
    def __init__(self, path, dev_mgr, log_handler):
        self.path = path
        self.transaction = DeviceConfigTransaction(path, dev_mgr, log_handler)

def DeviceConfigTransaction(path, dev_mgr, log_handler):
    return Transaction(_DeviceConfigTransaction(path, dev_mgr, log_handler))

class _DeviceConfigTransaction(_TransformTransactionBase):
    dev: odev.Device
    logger: logging.Logger

    def __init__(self, path, dev_mgr: odev.DeviceManager, log_handler):
        _TransformTransactionBase.__init__(self, path)
        self.dev = dev_mgr.get(path[-1])
        self.logger = logging.Logger(log_handler)

    def compute(self, tid, merged, out):
        return merged

    def finalize(self, tid):
        #print('#### (DeviceConfig)', self.path, 'finalize', tid)
        device = self.output
        if device is not None:
            if isinstance(device, gdata.ListElement):
                config = device.children["config"]
                if isinstance(config, gdata.Container):
                    cfg = gdata.Root(config.children)
                    self.dev.edit_config(cfg, tid)

    def on_completion(self, actself, tid, out, done):                            # (yield await)
        print('#### (DeviceConfig)', self.path, 'on_completion', tid)
        done('Ok')
