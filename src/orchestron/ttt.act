
import xml
import yang.gdata

def transpose(cfg_per_src: dict[str, yang.gdata.Node]) -> dict[str, dict[str, yang.gdata.Node]]:
    cfg_per_key = {}
    for src, conf in cfg_per_src.items():
        if isinstance(conf, yang.gdata.List):
            for le in conf.elements:
                key = le.key_str()
                if key in cfg_per_key:
                    cfg_per_key[key][src] = le
                else:
                    cfg_per_key[key] = {src: le}
        elif isinstance(conf, yang.gdata.Inner):
            for key, subconf in conf.children.items():
                if key in cfg_per_key:
                    cfg_per_key[key][src] = subconf
                else:
                    cfg_per_key[key] = {src: subconf}
        else:
            raise NotImplementedError("Unhandled configuration type" + str(type(conf)))

    return cfg_per_key

# TTT - Transactional Transform Trees

class TTTNode(object):
    proc def configure(self, diff: dict[str, yang.gdata.Node], output_tree: dict[str, yang.gdata.Node]):
        raise NotImplementedError("TTTNode.configure not implemented")

class TTTContainer(TTTNode):
    elems: dict[str, TTTNode]

    def __init__(self, elems: dict[str, TTTNode]):
        self.elems = elems

    proc def configure(self, diff: dict[str, yang.gdata.Node], output_tree: dict[str, yang.gdata.Node]):
        for path, subdiff in transpose(diff).items():
            if path in self.elems:
                elem = self.elems[path]
                elem.configure(subdiff, output_tree)

#actor TTTListState(template: proc() -> TTTNode):
#    var _elems = {}
#
#    def get_elems(keys: list[str]=[]) -> dict[str, TTTNode]:
#        res = {}
#        for key in keys:
#            res[key] = get_elem(key)
#        return res
#
#    def get_elem(key: str) -> TTTNode:
#        if key in _elems:
#            return _elems[key]
#        else:
#            raise ValueError("TTTListState.get_elem: key not found: " + key)
#            elem = _template()
#            _elems[key] = elem
#            return elem

class TTTListState(object):

    def __init__(self, template: mut() -> TTTNode):
        self._elems = {}
        self._template = template

    def get_elems(self, keys: list[str]=[]) -> dict[str, TTTNode]:
        res = {}
        for key in keys:
            res[key] = self.get_elem(key)
        return res

    def get_elem(self, key: str) -> TTTNode:
        if key in self._elems:
            return self._elems[key]
        else:
            elem = self._template()
            self._elems[key] = elem
            return elem


class TTTList(TTTNode):
    """We only support unordered lists
    """
    state: TTTListState

    def __init__(self, template: mut() -> TTTNode):
        self.state = TTTListState(template)

    proc def configure(self, diff: dict[str, yang.gdata.Node], output_tree: dict[str, yang.gdata.Node]):
        transp = transpose(diff)
        elems: dict[str, TTTNode] = self.state.get_elems(list(transp.keys()))
        for key, subdiff in transp.items():
            elem = elems[key]
            if isinstance(elem, TTTRFSTransform):
                # RFS transforms are special, they need to know about various
                # device information. RFS services always exist nested under a
                # list keyed by device name, so we can extract the device name
                # by visiting the parent node. It should already be verified at
                # compile time, but we have an extra check here on key length.
                l = list(diff.values())[0]
                lp = l.parent
                if isinstance(lp, yang.gdata.ListElement):
                    k = lp.key_vals
                    if len(k) != 1:
                        raise ValueError("RFSTransform parent list key length != 1")
                    di = DeviceInfo(lp.key_str())
                    elem.configure_rfs(di, subdiff, output_tree)
                else:
                    raise ValueError("RFSTransform parent not a ListElement")
            else:
                elem.configure(subdiff, output_tree)


#actor TTTTransformState(transform):
#    pass

class TTTTransform(TTTNode):
    def __init__(self):
        #self.state = TTTTransformState(self)
        pass

    mut def transform_wrapper(self, i: yang.gdata.Node) -> yang.gdata.Node:
        raise NotImplementedError("TTTTransform.transform not implemented")

    proc def configure(self, diff: dict[str, yang.gdata.Node], output_tree: dict[str, yang.gdata.Node]):
        print("TTTTransform.configure", self)
        diffs = list(diff.values())
        merged_config = diffs[0]
        for d in diffs[1:]:
            merged_config = yang.gdata.merge(merged_config, d)
        output = self.transform_wrapper(merged_config)
        output_tree[str(self)] = output
        print("TTTTransform.configure output:\n%s" % output.to_xmlstr())

class DeviceInfo(object):
    def __init__(self, name: str):
        self.name = name

class TTTRFSTransform(TTTNode):
    def __init__(self):
        #self.state = TTTTransformState(self)
        pass

    mut def transform_wrapper(self, i: yang.gdata.Node, device_info: DeviceInfo) -> yang.gdata.Node:
        raise NotImplementedError("TTTRFSTransform.transform not implemented")

    proc def configure_rfs(self, device_info: DeviceInfo, diff: dict[str, yang.gdata.Node], output_tree: dict[str, yang.gdata.Node]):
        print("TTTRFSTransform.configure", self)
        diffs = list(diff.values())
        merged_config = diffs[0]
        for d in diffs[1:]:
            merged_config = yang.gdata.merge(merged_config, d)
        # TODO: consider returning yang.gdata.Root instead of yang.gdata.Node from transform_wrapper()
        output = self.transform_wrapper(merged_config, device_info)
        # The root of the output tree from an RFS transform is the config of one
        # (1) device, while the combined output from all transforms on a TTT
        # layer is expected to be one data tree. Clearly we want to support
        # multiple devices, so we join the output trees of all RFS transforms
        # into a single data tree by inserting the device config under a list
        # keyed by device name. The device name is extracted from the parent
        # list element of the diff. The way the RFS transforms are expected to
        # be used is that they are always nested under a list keyed by device
        # name, so this is safe, it should be verified at compile time.

        if isinstance(output, yang.gdata.Root):
            rfs_output = yang.gdata.Module(
                name="orchestron-device",
                children={
                    "device": yang.gdata.List(
                        name="device",
                        keys=["name"],
                        elements=[
                            yang.gdata.ListElement(
                                [device_info.name],
                                children={"config": yang.gdata.Container("config", children=output.children)}
                            )
                        ]
                    )
                },
                ns="http://orchestron.org/yang/orchestron-device.yang"
            )
            output_tree[str(self)] = rfs_output
        else:
            raise NotImplementedError("TTTRFSTransform.configure_rfs: unsupported output type: " + str(type(output)))
        print("TTTRFSTransform.configure output:\n%s" % output.to_xmlstr())

class TTTDevice(TTTNode):
    def __init__(self):
        #self.state = TTTTransformState(self)
        print("TTTDevice.__init__")
        pass

    proc def configure(self, diff: dict[str, yang.gdata.Node], output_tree: dict[str, yang.gdata.Node]):
        print("TTTDevice.configure", self)
