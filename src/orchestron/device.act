import logging
import testing

import yang.adata
import yang.gdata

from orchestron.device_meta_config import orchestron_rfs__device_entry as DeviceMetaConfig

import netconf

NO_TRANSACTION = 0
IN_TRANSACTION = 1

NOT_CONNECTED = 0
CONNECTING = 1
CONNECTED = 2

class ModCap(object):
    name: str
    namespace: str
    revision: ?str
    feature: list[str]

    def __init__(self, name: str, namespace: str, revision: ?str=None, feature: list[str]=[]):
        self.name = name
        self.namespace = namespace
        self.revision = revision
        self.feature = feature

extension ModCap(Eq):
    def __eq__(self, other: ModCap) -> bool:
        self_revision = self.revision
        other_revision = other.revision
        revision_eq = (self_revision == None and other_revision == None) or (self_revision is not None and other_revision is not None and self_revision == other_revision)
        return self.name == other.name and self.namespace == other.namespace and revision_eq and self.feature == other.feature


actor DeviceManager(wcap: ?WorldCap=None, log_handler: logging.Handler):
    """Device Manager keeps track of all devices and hands out references to
    them based on name.

    There must only be a single Device instance per device, i.e. the same device
    name must always return the same Device instance.
    """
    var devices = {}

    action def _dummy_reconf(name: str):
        # Dummy reconf callback, used to avoid None
        pass

    var reconf_cb: action(str) -> None = _dummy_reconf

    def get(name: str) -> Device:
        if name not in devices:
            devices[name] = Device(wcap, name, log_handler, reconf_cb)
        dev = devices[name]
        return dev

    def on_reconf(on_reconf: action(str) -> None):
        reconf_cb = on_reconf


actor Device(wcap: ?WorldCap=None, name: str, log_handler: logging.Handler, on_reconf: action(str) -> None):
    """Device

    This is the Orchestron Device, it represents an abstract device in the
    system. Platform specific handling is implemented in the DeviceAdapter, i.e.
    in subclasses of DeviceAdapter, like NetconfDriver and MockAdapter.

    Device is used for the Device-actor whereas 'device' denotes the actual
    device that exists somewhere across the network.

    The Device actor sits between the TTT transaction engine and devices out in
    the real world. All changes from TTT are accepted, they are by definition
    the intended configuration for the device, thus the TTT API is fairly
    simple. Configuration is fed from TTT to Device asynchronously (nothing can
    go wrong) together with a transaction id (tid). If a TTT transaction wants
    to await the configuration to reach the device, that is possible via the
    wait_complete(tid). The device configuration interaction is serial, which
    means that we are either idling or have configuration in-transit to the
    device. If new configuration is received from TTT while we have
    configuration in-transit to the device, the new configuration is queued up
    and the associated transactions added to pending_txids. Once acknowledgement
    is received from the device, and thus the in-transit commit has concluded,
    the pending transactions, represented by intended_conf, can be pushed to the
    device.

    The device interaction is entirely asynchronous.

    """
    _log_handler = logging.Handler(name)
    _log_handler.set_handler(log_handler)
    _log_handler.set_output_level(logging.DEBUG)
    _log = logging.Logger(_log_handler)

    # Orchestron's intended configuration, that we want on the device. Note how
    # this is NOT the NMDA-speak "intended configuration" of the device itself.
    var intended_conf: ?yang.gdata.Node = None

    # The device's meta configuration, like address, credentials, etc.
    var dmc: ?DeviceMetaConfig = None

    var adapter: DeviceAdapter = NoAdapter(self, _log_handler, wcap)

    # The modules supported by the device.
    var modset: dict[str, ModCap] = {}

    # current_txids are the ids of the transactions that are currently
    # in-transit, which also means that we can determine if we have an
    # outstanding transaction by checking len(current_txids) > 0.
    var current_txids = set()
    # pending_txids are the ids of the transactions that are pending, which
    # means these transactions arrived while we already had configuration
    # in-transit to the device. When len(pending_txids) > 0, we need to
    # send the latest configuration after the current transaction is done.
    var pending_txids = set()
    # Note how intended_conf always only reflects the very latest configuration
    # that we received from the TTT transaction engine. When the device is ready
    # to receive configuration (we are connected, have said hello, gotten
    # capabilities, do not have an outstanding transaction), we will send the
    # intended_conf. A snapshot is taken and sent to the device. We do not keep
    # that particular version. If later the device failed to commit the
    # configuration and we need to retry, we will retry with a new
    # configuration.

    # TTT transactions can optionally request, through wait_complete(tid, cb), to
    # wait until configuration has been committed to the device. We keep track
    # of those callbacks keyed by tid.
    var callbacks: dict[str, action(value)->None] = {}

    def on_modset_update(new_modset: dict[str, ModCap]):
        _log.debug("Modset updated", {"new_modset": new_modset})
        on_reconf(name)

    def on_connect(new_modset: dict[str, ModCap]):
        _log.debug("Device connected", {"new_modset": new_modset})
        if modcap_eq(modset, new_modset):
            _log.debug("Supported modules unchanged")
        else:
            _log.debug("New supported modules, triggering RFS reconf")
            modset = new_modset
            on_reconf(name)

        if modset != {}:
            _log.debug("Sending config")
            _send_config()

    def set_dmc(new_dmc: DeviceMetaConfig) -> None:
        old_type = str(dmc.type) if dmc is not None else str(None)
        if old_type != str(new_dmc.type):
            _log.debug("Device type has changed, using new adapter", {"old_type": old_type, "new_type": str(new_dmc.type)})
            # TODO: map type fo adapter class
            adapter = NetconfAdapter(self, _log_handler, wcap)
        adapter.set_dmc(new_dmc)
        dmc = new_dmc

    def _transaction_done(success: bool):
        """Internal function called when transaction is done
        """
        # TODO: got to honour success flag, config hasn't actually reached the device if False
        for tid,callback in callbacks.items():
            if tid in current_txids:
                callback(success)
                del callbacks[tid]
        current_txids = set()
        if len(pending_txids) > 0:
            _log.debug("Configuration changed during in-progress transaction, running again...")
            _send_config()

    def _send_config():
        if len(current_txids) > 0:
            _log.debug("Device._send_config: there is currently an outstanding configuration, skipping")
        else:
            _log.debug("Device._send_config: sending intended configuration")
            if intended_conf is not None:
                current_txids = pending_txids
                pending_txids = set()
                adapter.configure(_transaction_done, intended_conf)
            else:
                _log.debug("_send_config: intended_conf not set")

    def configure(new_conf: yang.gdata.Node, tid: str="0"):
        _log.debug("Device.configure: got new configuration")
        pending_txids.add(tid)
        intended_conf = new_conf
        _send_config()

    def wait_complete(tid: str, done: action(value)->None):
        if tid not in current_txids | pending_txids:
            done(True) # Assume tid is very old and has already completed, thus respond immediately
        else:
            callbacks[tid] = done

    def get_capabilities():
        if adapter is not None:
            return adapter.get_capabilities()
        return []

    def get_modules() -> dict[str, ModCap]:
        if adapter is not None:
            return adapter.get_modules()
        return {}


class DeviceAdapter(object):
    """Abstract base class for Device Adapters
    """
    _log_handler: logging.Handler
    _wcap: ?WorldCap

    def __init__(self, dev: Device, log_handler, wcap):
        self._dev = dev
        self._log_handler = log_handler
        self._wcap = wcap
        self._log = logging.Logger(self._log_handler)

    proc def set_dmc(self, new_dmc: DeviceMetaConfig):
        raise NotImplementedError("DeviceAdapter.set_dmc() not implemented")

    proc def configure(self, done: action(bool) -> None, new_conf: yang.gdata.Node):
        """Configure the device with the given configuration

        :param done: callback to call when the configuration is done
        :param new_conf: the new configuration to apply
        """
        raise NotImplementedError("DeviceAdapter.configure() not implemented")

    proc def get_capabilities(self) -> list[str]:
        raise NotImplementedError("DeviceAdapter.get_capabilities() not implemented")

    proc def get_modules(self) -> dict[str, ModCap]:
        raise NotImplementedError("DeviceAdapter.get_modules() not implemented")

class NoAdapter(DeviceAdapter):
    def set_dmc(self, new_dmc):
        pass

    def configure(self, done, new_conf):
        # The NoAdapter cannot configure anything, so we just call done() with False
        done(False)

    def get_capabilities(self):
        return []

    def get_modules(self):
        return {}


class MockAdapter(DeviceAdapter):
    """Mock device adapter
    """
    def __init__(self, dev: Device, log_handler, wcap: ?WorldCap):
        self._dev = dev
        self._log_handler = log_handler
        self._wcap = wcap
        self._log = logging.Logger(self._log_handler)
        self._modset = {}
        self._dmc = None

    def set_dmc(self, new_dmc: DeviceMetaConfig):
        self._dmc = new_dmc
        self._log.debug("MockAdapter.set_dmc", {"new_dmc": new_dmc.to_gdata().to_xmlstr()})

#        preset_caps = []
#        if "cisco-ios-xr" in new_dmc.mock.preset:
#            preset_caps.extend([
#                "http://cisco.com/ns/yang/Cisco-IOS-XR-um-hostname-cfg?module=Cisco-IOS-XR-um-hostname-cfg&revision=2021-04-21",
#                "http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg?module=Cisco-IOS-XR-um-interface-cfg&revision=2022-07-11",
#                "http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-ipv4-cfg?module=Cisco-IOS-XR-um-if-ipv4-cfg&revision=2022-07-11",
#            ])
#        if "juniper-junos" in new_dmc.mock.preset:
#            preset_caps.extend([
#                "http://xml.juniper.net/netconf/junos/1.0",
#                "http://xml.juniper.net/dmi/system/1.0",
#            ])
#        for cap in preset_caps:
#            m = parse_cap(cap)
#            self._modset[m.name] = m
#            _log.debug("Adding preset cap", {"cap": m.name})
#
#        if len(new_dmc.mock.module.elements) > 0:
#            for mock_cap in new_dmc.mock.module.elements:
#                m = ModCap(mock_cap.name, mock_cap.namespace, mock_cap.revision, mock_cap.feature)
#                _log.debug("Adding mock cap", {"cap": m.name})
#                self._modset[m.name] = m
#        _log.debug("Device in MOCK mode, pretending to connect to device...")
#        _log.info("Device modset changed, triggering reconfiguration", {"device": name})
#        on_reconf(name)

    def configure(self, done, new_conf):
        self._log.debug("MockAdapter.configure", {"new_conf": new_conf.to_xmlstr()})
        done(True)

    proc def get_capabilities(self) -> list[str]:
        raise NotImplementedError("MockAdapter.get_capabilities() not implemented")

    proc def get_modules(self) -> dict[str, ModCap]:
        raise NotImplementedError("MockAdapter.get_modules() not implemented")

class NetconfAdapter(DeviceAdapter):

    def __init__(self, dev: Device, log_handler, wcap: ?WorldCap):
        self._dev = dev
        self._log_handler = log_handler
        self._wcap = wcap
        self._log = logging.Logger(self._log_handler)

        self.nc = NetconfDriver(self._dev, self._log_handler, self._wcap)
        self._log.debug("NetconfAdapter starting")

    def set_dmc(self, new_dmc: DeviceMetaConfig):
        self.nc.set_dmc(new_dmc)

    def configure(self, done, new_conf):
        return self.nc.configure(done, new_conf)

    def get_capabilities(self) -> list[str]:
        return self.nc.get_capabilities()

    def get_modules(self) -> dict[str, ModCap]:
        return self.nc.get_modules()

actor NetconfDriver(dev: Device, log_handler: logging.Handler, wcap: ?WorldCap):
    """NETCONF device adapter
    """
    _log = logging.Logger(log_handler)
    _log.info("NetconfDriver starting up")

    # Orchestron's intended configuration, that we want on the device. Note how
    # this is NOT the NMDA-speak "intended configuration" of the device itself
    var intended_conf: ?yang.gdata.Node = None

    # The currently running configuration on the device (which in NMDA lingo is
    # the "intended configuration" of the device)
    var running_conf: ?yang.gdata.Node = None

    # The device's meta configuration, like address, credentials, etc.
    var dmc: ?DeviceMetaConfig = None

    # The NETCONF client connection to the device
    var client: ?netconf.Client = None

    var conn_state: int = NOT_CONNECTED
    var txn_state: int = NO_TRANSACTION
    var on_done: ?action(bool) -> None = None

    var modset: dict[str, ModCap] = {}

    def _on_connect(c):
        _log.info("Connected to device")
        conn_state = CONNECTED

        new_modset: dict[str, ModCap] = {}
        for cap in c.get_capabilities():
            m = parse_cap(cap)
            new_modset[m.name] = m

        if not modcap_eq(modset, new_modset):
            modset = new_modset

        dev.on_connect(modset)

    def _on_error(c, error):
        modset = {}
        _log.debug("Error connecting to device")

    def _on_notif(c, n):
        _log.debug("Notification from device")

    def set_dmc(new_dmc: DeviceMetaConfig):
        _log.debug("Device.set_meta_config")

        if conn_state == CONNECTED:
            # TODO: heh, obviously DO NOT DO THIS :P
            _log.debug("Device already connected, ignoring new config")
            return

#        if dmc is not None:
#            # TODO: should compare existing dmc with new_dmc
#            if dmc.to_gdata() == new_dmc.to_gdata():
#                _log.debug("Device Meta Config already set to same value")
#                return

        #_log.debug(new_dmc.to_gdata().to_xmlstr())

        if not len(new_dmc.address.elements) > 0:
            _log.debug("Not enough addressess :/")
            return

        addr = new_dmc.address.elements[0]
        address = addr.address
        addr_port = addr.port
        port = int(addr_port) if addr_port is not None else 830
        username = new_dmc.credentials.username
        password = new_dmc.credentials.password

        if wcap is not None and username is not None and password is not None:
            conn_state = CONNECTING
            _log.debug("Setting up NETCONF client... %s %d %s %s" % (address, port, username, password))
            c = netconf.Client(wcap, address, port, username, password,
                               on_connect=_on_connect,
                               on_error=_on_error,
                               on_notif=_on_notif,
                               log_handler=log_handler)
            client = c
        dmc = new_dmc

    def configure(done: action(bool) -> None, new_conf: yang.gdata.Node):
        if on_done is not None:
            _log.debug("Device.configure: already in progress")
            return

        if intended_conf == new_conf:
            _log.debug("Device.configure: ignoring new configuration identical to current intended configuration")
            done(True)
        else:
            _log.debug("Device.configure: new configuration")
            if conn_state != CONNECTED:
                _log.debug("Device.configure: device not connected, cannot send configuration")
                done(False)
                return

            intended_conf = new_conf
            xml_conf = new_conf.to_xmlstr(pretty=False)
            if xml_conf == "":
                # Cisco IOS XRd doesn't like empty <edit-config>, returns error
                _log.debug("Device.edit_config Config is empty, noop")
                done(True)
                return

            if client is not None:
                _log.debug("Device.edit_config Sending config...")
                on_done = done
                if txn_state == IN_TRANSACTION:
                    return
                txn_state = IN_TRANSACTION
                if _is_writable_running():
                    client.edit_config(xml_conf, _on_conf)
                else:
                    client.edit_config(xml_conf, _on_conf, datastore="candidate")
            else:
                _log.debug("Device.edit_config No client, cannot send config")


    def get_capabilities():
        if client is not None:
            return client.get_capabilities()
        return []

    def get_modules():
        return modset

    def _is_writable_running():
        return ":writable-running" in modset

    def _transaction_done(success: bool):
        """Internal function called when transaction is done
        """
        if on_done is not None:
            on_done(success)
        on_done = None

    def _on_conf(c, r):
        if r is not None:
            _log.debug("Device._on_conf", {"r": r.encode()})
            if not _is_writable_running():
                # We edit-config'd candidate, now commit
                c.commit(_on_commit)
            else:
                _transaction_done(True)
        else:
            _log.debug("Device._on_conf: Device disconnected")
            _transaction_done(False)

    def _on_commit(c, r):
        if r is not None:
            _log.debug("Device._on_commit", {"r": r.encode()})
            if any(filter(lambda c: c.tag == "rpc-error", r.children)) and not _is_writable_running():
                # We commit'ed candidate, but got an error, now discard-changes
                # TODO: what if the device does this (:rollback-on-error)?!
                c.discard_changes(_on_discard_changes)
            else:
                _transaction_done(True)
        else:
            _log.debug("Device._on_commit: Device disconnected")
            _transaction_done(False)

    def _on_discard_changes(c, r):
        if r is not None:
            _log.debug("Device._on_discard_changes", {"r": r.encode()})
            _transaction_done(False)
        else:
            _log.debug("Device._on_discard_changes: Device disconnected")
            _transaction_done(False)



def modcap_eq(a: dict[str, ModCap], b: dict[str, ModCap]) -> bool:
    if len(a) != len(b):
        return False
    if set(a.keys()) != set(b.keys()):
        return False
    for k in a.keys():
        if a[k] != b[k]:
            return False
    return True


def parse_cap(tcap: str) -> ModCap:
    parts = tcap.split("?", 1)

    name = parts[0]
    namespace = parts[0]
    revision = None
    feature = []

    qps = {}
    if len(parts) > 1:
        qparts = parts[1].split("&")
        for qpart in qparts:
            qkvparts = qpart.split("=")
            if len(qkvparts) == 2:
                qk, qv = qkvparts[0], qkvparts[1]
                qps[qk] = qv

    if "module" in qps:
        name = qps["module"]
    if "revision" in qps:
        revision = qps["revision"]

    return ModCap(name, namespace, revision, feature)


def _test_parse_cap_base():
    mod = parse_cap("urn:ietf:params:netconf:base:1.1")
    testing.assertEqual(mod.name, "urn:ietf:params:netconf:base:1.1")
    testing.assertEqual(mod.namespace, "urn:ietf:params:netconf:base:1.1")
    testing.assertEqual(mod.revision, None)
    testing.assertEqual(mod.feature, [])

def _test_parse_cap_xr_isis():
    mod = parse_cap("http://cisco.com/ns/yang/Cisco-IOS-XR-isis-act?module=Cisco-IOS-XR-isis-act&revision=2019-10-01")
    testing.assertEqual(mod.name, "Cisco-IOS-XR-isis-act")
    testing.assertEqual(mod.namespace, "http://cisco.com/ns/yang/Cisco-IOS-XR-isis-act")
    testing.assertEqual(mod.revision, "2019-10-01")
    testing.assertEqual(mod.feature, [])

def _test_parse_cap_xr_hostname():
    mod = parse_cap("http://cisco.com/ns/yang/Cisco-IOS-XR-um-hostname-cfg?module=Cisco-IOS-XR-um-hostname-cfg&revision=2021-04-21")
    testing.assertEqual(mod.name, "Cisco-IOS-XR-um-hostname-cfg")
    testing.assertEqual(mod.namespace, "http://cisco.com/ns/yang/Cisco-IOS-XR-um-hostname-cfg")
    testing.assertEqual(mod.revision, "2021-04-21")
    testing.assertEqual(mod.feature, [])
